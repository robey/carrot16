var exports = {};
// Generated by CoffeeScript 1.3.3
(function() {
  var Assembler, AssemblerError, AssemblerOutput, BuiltinMacros, DataLine, Dcpu, Expression, Line, Macro, Operand, ParsedLine, Parser, PrettyPrinter, Span, hex, padding, pp, prettyPrinter, x,
    __slice = [].slice;










  padding = "0000";

  hex = function(n) {
    var rv;
    rv = n.toString(16);
    return "0x" + padding.slice(0, 4 - rv.length) + rv;
  };

  DataLine = (function() {

    function DataLine(pline, address, data) {
      this.pline = pline;
      this.address = address != null ? address : 0;
      this.data = data != null ? data : [];
      this.expanded = null;
    }

    DataLine.prototype.toString = function() {
      var data, extra,
        _this = this;
      extra = this.expanded != null ? "{ " + this.expanded.map(function(x) {
        return x.toString();
      }).join(" / ") + " }" : "";
      data = this.data.map(function(item) {
        if (item instanceof Expression) {
          return item.toString();
        } else {
          return hex(item);
        }
      });
      return ("" + (hex(this.address)) + ": ") + data.join(", ") + extra;
    };

    DataLine.prototype.fail = function(message) {
      throw new AssemblerError(this.pline.line.text, 0, message);
    };

    DataLine.prototype.flatten = function() {
      var address, dline, x, _i, _j, _len, _len1, _ref, _ref1;
      if (!(this.expanded != null)) {
        return;
      }
      address = this.address;
      if (this.data.length > 0) {
        this.fail("Internal error: Expanded macro has data");
      }
      _ref = this.expanded;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dline = _ref[_i];
        if (dline.address !== address) {
          this.fail("Internal error: Disjunct expanded macro");
        }
        _ref1 = dline.data;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          x = _ref1[_j];
          if (typeof x !== 'number') {
            this.fail("Internal error: unresolved expression");
          }
        }
        this.data = this.data.concat(dline.data);
        address += dline.data.length;
      }
      return delete this.expanded;
    };

    DataLine.prototype.nextAddress = function() {
      var address, dline, _i, _len, _ref;
      address = this.address;
      if (this.expanded != null) {
        _ref = this.expanded;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dline = _ref[_i];
          address += dline.data.length;
        }
      }
      address += this.data.length;
      return address;
    };

    DataLine.prototype.pack = function(dlines) {
      var address, addressStart, blocks, data, end, i, j, k, n, runStart, _i, _ref;
      i = 0;
      end = dlines.length;
      blocks = [];
      while (i < end) {
        runStart = i;
        addressStart = address = dlines[i].address;
        while (i < end && dlines[i].address === address) {
          address += dlines[i].data.length;
          i++;
        }
        data = new Array(address - addressStart);
        n = 0;
        for (j = _i = runStart; runStart <= i ? _i < i : _i > i; j = runStart <= i ? ++_i : --_i) {
          k = dlines[j].data.length;
          [].splice.apply(data, [n, (n + k) - n].concat(_ref = dlines[j].data)), _ref;
          n += k;
        }
        if (data.length > 0) {
          blocks.push(new DataLine(null, addressStart, data));
        }
      }
      blocks.sort(function(a, b) {
        return a.address > b.address;
      });
      return blocks;
    };

    return DataLine;

  })();

  Assembler = (function() {

    function Assembler(logger, maxErrors) {
      this.logger = logger;
      this.maxErrors = maxErrors != null ? maxErrors : 10;
      if (!(this.logger != null)) {
        this.logger = function(lineNumber, pos, reason) {};
      }
      this.reset();
    }

    Assembler.prototype.reset = function() {
      this.symtab = {};
      this.constants = {};
      this.errors = [];
      return this.recompile = false;
    };

    Assembler.prototype.debug = function() {
      var item, list, slist;
      list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this["debugger"] == null) {
        return;
      }
      slist = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          item = list[_i];
          switch (typeof item) {
            case 'string':
              _results.push(item.toString());
              break;
            default:
              _results.push(pp(item));
          }
        }
        return _results;
      })();
      return this["debugger"](slist.join(""));
    };

    Assembler.prototype.fail = function(x, message) {
      throw new AssemblerError(this.text, x, message);
    };

    Assembler.prototype.error = function(lineNumber, pos, reason) {
      var x, _i, _len, _ref;
      _ref = this.errors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        if (x[0] === lineNumber && x[1] === pos && x[2] === reason) {
          return;
        }
      }
      this.debug("  error on line " + lineNumber + " at " + pos + ": " + reason);
      this.logger(lineNumber, pos, reason);
      return this.errors.push([lineNumber, pos, reason]);
    };

    Assembler.prototype.giveUp = function() {
      return this.errors.length >= this.maxErrors;
    };

    Assembler.prototype.process = function(lineNumber, f, transformer) {
      var pos, reason, _ref;
      if (this.giveUp()) {
        return null;
      }
      try {
        return f();
      } catch (e) {
        if (e.type !== "AssemblerError") {
          throw e;
        }
        pos = e.pos != null ? e.pos : 0;
        reason = e.reason != null ? e.reason : e.toString();
        if (transformer != null) {
          _ref = transformer(lineNumber, pos, reason), lineNumber = _ref[0], pos = _ref[1], reason = _ref[2];
        }
        this.error(lineNumber, pos, reason);
        if (this.giveUp()) {
          this.error(lineNumber, pos, "Too many errors; giving up.");
        }
        return null;
      }
    };

    Assembler.prototype.compile = function(textLines, address) {
      var dline, dlines, i, k, originalAddress, plines, v, _i, _j, _len, _ref, _ref1,
        _this = this;
      if (address == null) {
        address = 0;
      }
      plines = this.parse(textLines);
      if (this.giveUp()) {
        return new AssemblerOutput(this.errors, [], this.symtab);
      }
      this.recompile = true;
      originalAddress = address;
      while (this.recompile) {
        this.recompile = false;
        address = originalAddress;
        this.symtab = {};
        _ref = this.constants;
        for (k in _ref) {
          v = _ref[k];
          this.symtab[k] = v;
        }
        dlines = plines.map(function(pline) {
          var dline;
          if (pline != null) {
            dline = _this.process(pline.lineNumber, function() {
              return _this.compileLine(pline, address);
            });
            _this.debug("  data: ", dline);
            if (dline != null) {
              address = dline.nextAddress();
            }
            return dline;
          } else {
            return null;
          }
        });
        for (_i = 0, _len = dlines.length; _i < _len; _i++) {
          dline = dlines[_i];
          if (dline != null) {
            this.resolveLine(dline);
            dline.flatten();
            for (i = _j = 0, _ref1 = dline.data.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
              if (typeof dline.data[i] === "object") {
                dline.data[i] = 0;
              }
            }
          }
        }
      }
      return new AssemblerOutput(this.errors, dlines, this.symtab);
    };

    Assembler.prototype.parse = function(textLines) {
      var i, parser, pline, plines, text, _i, _j, _len, _len1,
        _this = this;
      parser = new Parser();
      parser["debugger"] = this["debugger"];
      this.addBuiltinMacros(parser);
      plines = [];
      for (i = _i = 0, _len = textLines.length; _i < _len; i = ++_i) {
        text = textLines[i];
        pline = this.process(i, function() {
          return parser.parseLine(text, i);
        });
        if (this.giveUp()) {
          return [];
        }
        plines.push(pline);
      }
      this.addConstants(parser.constants);
      for (_j = 0, _len1 = plines.length; _j < _len1; _j++) {
        pline = plines[_j];
        if (pline != null) {
          pline.foldConstants(this.symtab);
        }
      }
      return plines;
    };

    Assembler.prototype.addConstants = function(constants) {
      var k, progress, unresolved, v, _results;
      unresolved = {};
      for (k in constants) {
        v = constants[k];
        unresolved[k] = v;
      }
      _results = [];
      while (Object.keys(unresolved).length > 0) {
        progress = false;
        for (k in unresolved) {
          v = unresolved[k];
          if (v.resolvable(this.constants)) {
            this.constants[k] = v.evaluate(this.constants) & 0xffff;
            delete unresolved[k];
            progress = true;
          }
        }
        if (!progress) {
          _results.push((function() {
            var _results1,
              _this = this;
            _results1 = [];
            for (k in unresolved) {
              v = unresolved[k];
              _results1.push(this.process(v.lineNumber, function() {
                return v.evaluate(_this.constants) & 0xffff;
              }));
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Assembler.prototype.addBuiltinMacros = function(parser) {
      var lineNumber, text, _i, _len, _ref, _results;
      _ref = BuiltinMacros.split("\n");
      _results = [];
      for (lineNumber = _i = 0, _len = _ref.length; _i < _len; lineNumber = ++_i) {
        text = _ref[lineNumber];
        _results.push(parser.parseLine(text, -1));
      }
      return _results;
    };

    Assembler.prototype.compileLine = function(pline, address) {
      var data, dline,
        _this = this;
      this.debug("+ compiling @ ", address, ": ", pline);
      this.symtab["."] = address;
      this.symtab["$"] = address;
      if (pline.directive != null) {
        switch (pline.directive) {
          case "org":
            address = pline.data[0];
        }
      }
      if (pline.label != null) {
        this.symtab[pline.label] = address;
      }
      if (pline.data.length > 0 && !(pline.directive != null)) {
        data = pline.data.map(function(expr) {
          if ((expr instanceof Expression) && expr.resolvable(_this.symtab)) {
            return expr.evaluate(_this.symtab) & 0xffff;
          } else {
            return expr;
          }
        });
        return new DataLine(pline, address, data);
      }
      if (pline.expanded != null) {
        dline = new DataLine(pline, address, []);
        dline.expanded = pline.expanded.map(function(x) {
          var dataLine;
          dataLine = _this.compileLine(x, address);
          address = dataLine.address + dataLine.data.length;
          return dataLine;
        });
        return dline;
      }
      if (!(pline.op != null)) {
        return new DataLine(pline, address, []);
      }
      dline = new DataLine(pline, address);
      this.fillInstruction(dline);
      return dline;
    };

    Assembler.prototype.resolveLine = function(dline, transformer) {
      var dl, operand, operands, _i, _len, _ref, _results,
        _this = this;
      if (transformer == null) {
        transformer = null;
      }
      this.debug("+ resolving @ ", dline.address, ": ", dline);
      this.symtab["."] = dline.address;
      this.symtab["$"] = dline.address;
      dline.data = dline.data.map(function(item) {
        var value;
        if (item instanceof Expression) {
          value = _this.process(dline.pline.lineNumber, (function() {
            return item.evaluate(_this.symtab) & 0xffff;
          }), transformer);
          if (value != null) {
            return value;
          } else {
            return 0;
          }
        } else {
          return item;
        }
      });
      this.fillInstruction(dline, true);
      this.optimize(dline.pline);
      operands = dline.pline.operands;
      if (operands.length > 0) {
        operand = operands[operands.length - 1];
        if (operand.checkCompact(this.symtab)) {
          this.debug("  compacted ", operand);
          this.recompile = true;
        }
      }
      if (dline.expanded != null) {
        _ref = dline.expanded;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dl = _ref[_i];
          transformer = function(y, x, reason) {
            var argOffset, _j, _len1, _ref1;
            _ref1 = dl.pline.macroArgOffsets;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              argOffset = _ref1[_j];
              if (x >= argOffset.left && x <= argOffset.right) {
                y = dline.pline.lineNumber;
                x = dline.pline.macroArgIndexes[argOffset.arg];
              }
            }
            return [y, x, reason];
          };
          _results.push(this.resolveLine(dl, transformer));
        }
        return _results;
      }
    };

    Assembler.prototype.fillInstruction = function(dline, force) {
      var code, i, immediate, operandCodes, pline, _i, _ref, _ref1;
      if (force == null) {
        force = false;
      }
      pline = dline.pline;
      if (!(pline.op != null)) {
        return;
      }
      dline.data = [0];
      operandCodes = [];
      if (pline.operands.length > 0) {
        for (i = _i = _ref = pline.operands.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
          _ref1 = pline.operands[i].pack(this.symtab), code = _ref1[0], immediate = _ref1[1];
          operandCodes.push(code);
          if (immediate != null) {
            if ((immediate instanceof Expression) && force) {
              dline.data.push(0);
            } else {
              dline.data.push(immediate);
            }
          }
        }
      }
      if (Dcpu.BinaryOp[pline.op] != null) {
        return dline.data[0] = (operandCodes[0] << 10) | (operandCodes[1] << 5) | Dcpu.BinaryOp[pline.op];
      } else if (Dcpu.SpecialOp[pline.op] != null) {
        return dline.data[0] = (operandCodes[0] << 10) | (Dcpu.SpecialOp[pline.op] << 5);
      }
    };

    Assembler.prototype.optimize = function(pline) {
      return this.optimizeAdd(pline);
    };

    Assembler.prototype.optimizeAdd = function(pline) {
      var value, _ref;
      if (pline.op !== "add" && pline.op !== "sub") {
        return;
      }
      value = pline.operands[1].immediateValue(this.symtab);
      if (!(value != null) || value < 0xff00) {
        return;
      }
      if ((_ref = pline.operands[0].code) !== Dcpu.Specials.pc && _ref !== Dcpu.Specials.sp) {
        return;
      }
      pline.op = (pline.op === "add" ? "sub" : "add");
      if (pline.operands[1].expr != null) {
        pline.operands[1].expr = Expression.prototype.Unary("", 0, "-", pline.operands[1].expr);
        pline.operands[1].immediate = null;
      } else {
        pline.operands[1].immediate = 0x10000 - value;
      }
      this.recompile = true;
      return this.debug("  optimize/add: ", pline);
    };

    return Assembler;

  })();

  exports.DataLine = DataLine;

  exports.Assembler = Assembler;

  BuiltinMacros = "\n.macro jmp(addr) {\n  set pc, addr\n}\n\n.macro hlt {\n  sub pc, 1\n}\n\n.macro ret {\n  set pc, pop\n}\n\n.macro bra(addr) {\n.onerror \"Illegal argument to BRA.\"\n  add pc, addr - .next\n:.next\n}\n";

  exports.BuiltinMacros = BuiltinMacros;

  Dcpu = {
    Registers: {
      "a": 0,
      "b": 1,
      "c": 2,
      "x": 3,
      "y": 4,
      "z": 5,
      "i": 6,
      "j": 7
    },
    RegisterNames: "ABCXYZIJ",
    Specials: {
      "push": 0x18,
      "pop": 0x18,
      "peek": 0x19,
      "pick": 0x1a,
      "sp": 0x1b,
      "pc": 0x1c,
      "ex": 0x1d
    },
    BinaryOp: {
      "set": 0x01,
      "add": 0x02,
      "sub": 0x03,
      "mul": 0x04,
      "mli": 0x05,
      "div": 0x06,
      "dvi": 0x07,
      "mod": 0x08,
      "mdi": 0x09,
      "and": 0x0a,
      "bor": 0x0b,
      "xor": 0x0c,
      "shr": 0x0d,
      "asr": 0x0e,
      "shl": 0x0f,
      "ifb": 0x10,
      "ifc": 0x11,
      "ife": 0x12,
      "ifn": 0x13,
      "ifg": 0x14,
      "ifa": 0x15,
      "ifl": 0x16,
      "ifu": 0x17,
      "adx": 0x1a,
      "sbx": 0x1b,
      "sti": 0x1e,
      "std": 0x1f
    },
    SpecialOp: {
      "jsr": 0x01,
      "hcf": 0x07,
      "int": 0x08,
      "iag": 0x09,
      "ias": 0x0a,
      "rfi": 0x0b,
      "iaq": 0x0c,
      "hwn": 0x10,
      "hwq": 0x11,
      "hwi": 0x12
    }
  };

  Dcpu.Reserved = ((function() {
    var _results;
    _results = [];
    for (x in Dcpu.Registers) {
      _results.push(x);
    }
    return _results;
  })()).concat((function() {
    var _results;
    _results = [];
    for (x in Dcpu.Specials) {
      _results.push(x);
    }
    return _results;
  })());

  Dcpu.RegisterRegex = new RegExp("^(" + Dcpu.Reserved.join("|") + ")\\b", "i");

  Dcpu.ReservedOp = ((function() {
    var _results;
    _results = [];
    for (x in Dcpu.BinaryOp) {
      _results.push(x);
    }
    return _results;
  })()).concat((function() {
    var _results;
    _results = [];
    for (x in Dcpu.SpecialOp) {
      _results.push(x);
    }
    return _results;
  })()).concat(["jmp", "hlt", "ret", "bra", "dat", "org", "equ"]);

  exports.Dcpu = Dcpu;

  AssemblerError = (function() {

    function AssemblerError(text, pos, reason) {
      this.text = text;
      this.pos = pos;
      this.reason = reason;
      this.setReason(this.reason);
      this.type = "AssemblerError";
    }

    AssemblerError.prototype.format = function(reason) {
      var i, spacer;
      spacer = this.pos === 0 ? "" : ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.pos; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(" ");
        }
        return _results;
      }).call(this)).join("");
      return "\n" + this.text + "\n" + spacer + "^\n" + reason + "\n";
    };

    AssemblerError.prototype.setReason = function(reason) {
      this.reason = reason;
      return this.message = this.format(this.reason);
    };

    return AssemblerError;

  })();

  exports.AssemblerError = AssemblerError;



  Expression = (function() {

    Expression.prototype.Register = function(text, pos, name) {
      var e;
      e = new Expression(text, pos);
      e.register = name.toLowerCase();
      e.evaluate = function(symtab) {
        throw new AssemblerError(this.text, this.pos, "Constant expressions may not contain register references");
      };
      e.toString = function() {
        return this.register.toUpperCase();
      };
      e.resolvable = function(symtab) {
        if (symtab == null) {
          symtab = {};
        }
        return true;
      };
      return e;
    };

    Expression.prototype.Literal = function(text, pos, n) {
      var e;
      if (n > 0xffff || n < -0x8000) {
        throw new AssemblerError(text, pos, "16-bit value is out of range: " + n);
      }
      e = new Expression(text, pos);
      e.literal = n;
      e.evaluate = function(symtab) {
        return this.literal;
      };
      e.toString = function() {
        return this.literal.toString();
      };
      e.resolvable = function(symtab) {
        if (symtab == null) {
          symtab = {};
        }
        return true;
      };
      return e;
    };

    Expression.prototype.Label = function(text, pos, x) {
      var e;
      e = new Expression(text, pos);
      e.label = x;
      e.evaluate = function(symtab) {
        if (!(symtab[this.label] != null)) {
          throw new AssemblerError(this.text, this.pos, "Can't resolve reference to " + this.label);
        }
        return symtab[this.label];
      };
      e.toString = function() {
        return this.label;
      };
      e.resolvable = function(symtab) {
        if (symtab == null) {
          symtab = {};
        }
        return symtab[this.label] != null;
      };
      return e;
    };

    Expression.prototype.Unary = function(text, pos, op, r) {
      var e;
      e = new Expression(text, pos);
      e.unary = op;
      e.right = r;
      e.evaluate = function(symtab) {
        r = this.right.evaluate(symtab);
        switch (this.unary) {
          case '-':
            return -r;
          default:
            return r;
        }
      };
      e.toString = function() {
        return "(" + this.unary + this.right.toString() + ")";
      };
      e.resolvable = function(symtab) {
        if (symtab == null) {
          symtab = {};
        }
        return this.right.resolvable(symtab);
      };
      return e;
    };

    Expression.prototype.Binary = function(text, pos, op, l, r) {
      var e;
      e = new Expression(text, pos);
      e.binary = op;
      e.left = l;
      e.right = r;
      e.evaluate = function(symtab) {
        l = this.left.evaluate(symtab);
        r = this.right.evaluate(symtab);
        switch (this.binary) {
          case '+':
            return l + r;
          case '-':
            return l - r;
          case '*':
            return l * r;
          case '/':
            return l / r;
          case '%':
            return l % r;
          case '<<':
            return l << r;
          case '>>':
            return l >> r;
          case '&':
            return l & r;
          case '^':
            return l ^ r;
          case '|':
            return l | r;
          case '<':
            if (l < r) {
              return 1;
            } else {
              return 0;
            }
          case '>':
            if (l > r) {
              return 1;
            } else {
              return 0;
            }
          case '<=':
            if (l <= r) {
              return 1;
            } else {
              return 0;
            }
          case '>=':
            if (l >= r) {
              return 1;
            } else {
              return 0;
            }
          case '==':
            if (l === r) {
              return 1;
            } else {
              return 0;
            }
          case '!=':
            if (l !== r) {
              return 1;
            } else {
              return 0;
            }
          default:
            throw new AssemblerError(this.text, this.pos, "Internal error (undefined binary operator)");
        }
      };
      e.toString = function() {
        return "(" + this.left.toString() + " " + this.binary + " " + this.right.toString() + ")";
      };
      e.resolvable = function(symtab) {
        if (symtab == null) {
          symtab = {};
        }
        return this.left.resolvable(symtab) && this.right.resolvable(symtab);
      };
      return e;
    };

    function Expression(text, pos) {
      this.text = text;
      this.pos = pos;
    }

    Expression.prototype.toString = function() {
      throw "must be implemented in objects";
    };

    Expression.prototype.resolvable = function(symtab) {
      if (symtab == null) {
        symtab = {};
      }
      throw "must be implemented in objects";
    };

    Expression.prototype.evaluate = function(symtab) {
      if (symtab == null) {
        symtab = {};
      }
      throw "must be implemented in objects";
    };

    return Expression;

  })();

  exports.Expression = Expression;



  Span = (function() {

    function Span(type, start, end) {
      this.type = type;
      this.start = start;
      this.end = end;
    }

    return Span;

  })();

  Span.Comment = "comment";

  Span.Directive = "directive";

  Span.Identifier = "identifier";

  Span.Operator = "operator";

  Span.String = "string";

  Span.StringEscape = "string-escape";

  Span.Register = "register";

  Span.Number = "number";

  Span.Instruction = "instruction";

  Span.Label = "label";

  Line = (function() {

    function Line(text, options) {
      this.text = text;
      this.options = options != null ? options : {};
      this.pos = 0;
      this.end = this.text.length;
      this.spans = [];
    }

    Line.prototype.setText = function(text) {
      this.text = text;
      this.pos = 0;
      return this.end = text.length;
    };

    Line.prototype.addSpan = function(type, start, end) {
      var old;
      if (this.spans.length > 0 && this.spans[this.spans.length - 1].end === start && this.spans[this.spans.length - 1].type === type) {
        old = this.spans.pop();
        return this.spans.push(new Span(type, old.start, end));
      } else {
        return this.spans.push(new Span(type, start, end));
      }
    };

    Line.prototype.htmlEscape = function(s) {
      return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };

    Line.prototype.toHtml = function() {
      var rv, span, _i, _len, _ref;
      x = 0;
      rv = "";
      _ref = this.spans;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        span = _ref[_i];
        if (x < span.start) {
          rv += this.htmlEscape(this.text.slice(x, span.start));
        }
        rv += "<span class=\"syntax-" + span.type + "\">" + (this.htmlEscape(this.text.slice(span.start, span.end))) + "</span>";
        x = span.end;
      }
      if (x < this.text.length) {
        rv += this.htmlEscape(this.text.slice(x));
      }
      return rv;
    };

    Line.prototype.toDebug = function() {
      var rv, span, _i, _len, _ref;
      x = 0;
      rv = "";
      _ref = this.spans;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        span = _ref[_i];
        if (x < span.start) {
          rv += this.text.slice(x, span.start);
        }
        rv += "{" + span.type + ":" + this.text.slice(span.start, span.end) + "}";
        x = span.end;
      }
      if (x < this.text.length) {
        rv += this.text.slice(x);
      }
      return rv;
    };

    Line.prototype.fail = function(message) {
      if (!this.options.ignoreErrors) {
        throw new AssemblerError(this.text, this.pos, message);
      }
    };

    Line.prototype.finished = function() {
      return this.pos === this.end;
    };

    Line.prototype.mark = function() {
      return {
        pos: this.pos,
        spanLength: this.spans.length
      };
    };

    Line.prototype.rewind = function(m) {
      this.pos = m.pos;
      return this.spans = this.spans.slice(0, m.spanLength);
    };

    Line.prototype.pointTo = function(m) {
      return this.pos = m.pos;
    };

    Line.prototype.scan = function(s, type) {
      var len;
      len = s.length;
      if (this.pos + len <= this.end && this.text.slice(this.pos, this.pos + len).toLowerCase() === s) {
        this.addSpan(type, this.pos, this.pos + len);
        this.pos += len;
        return true;
      } else {
        return false;
      }
    };

    Line.prototype.scanAssert = function(s, type) {
      if (!this.scan(s, type)) {
        return this.fail("Expected " + s);
      }
    };

    Line.prototype.scanAhead = function(s) {
      var len;
      len = s.length;
      return this.pos + len <= this.end && this.text.slice(this.pos, this.pos + len).toLowerCase() === s;
    };

    Line.prototype.match = function(regex, type) {
      var m;
      m = regex.exec(this.text.slice(this.pos));
      if (!(m != null)) {
        return null;
      }
      this.addSpan(type, this.pos, this.pos + m[0].length);
      this.pos += m[0].length;
      return m[0];
    };

    Line.prototype.matchAhead = function(regex) {
      return regex.exec(this.text.slice(this.pos)) != null;
    };

    Line.prototype.skipWhitespace = function() {
      var c;
      if (this.pos >= this.end) {
        return;
      }
      c = this.text[this.pos];
      while (this.pos < this.end && (c === " " || c === "\t" || c === "\r" || c === "\n")) {
        c = this.text[++this.pos];
      }
      if (c === ';') {
        this.addSpan(Span.Comment, this.pos, this.end);
        return this.end = this.pos;
      }
    };

    Line.prototype.parseChar = function() {
      var rv, start;
      if (this.text[this.pos] !== "\\" || this.pos + 1 === this.end) {
        this.addSpan(Span.String, this.pos, this.pos + 1);
        return this.text[this.pos++];
      }
      start = this.pos;
      this.pos += 2;
      rv = (function() {
        switch (this.text[this.pos - 1]) {
          case 'e':
            return "\x1b";
          case 'n':
            return "\n";
          case 'r':
            return "\r";
          case 't':
            return "\t";
          case 'z':
            return "\u0000";
          case 'x':
            if (this.pos + 1 < this.end) {
              this.pos += 2;
              return String.fromCharCode(parseInt(this.text.slice(this.pos - 2, this.pos), 16));
            } else {
              return "\\x";
            }
            break;
          default:
            return "\\" + this.text[this.pos - 1];
        }
      }).call(this);
      this.addSpan(Span.StringEscape, start, this.pos);
      return rv;
    };

    Line.prototype.parseString = function() {
      var rv;
      rv = "";
      if (!this.scan('"', Span.String)) {
        this.fail("Expected string");
      }
      while (!this.finished() && this.text[this.pos] !== '"') {
        rv += this.parseChar();
      }
      this.scanAssert('"', Span.String);
      return rv;
    };

    Line.prototype.parseWord = function(name, type) {
      var word;
      if (type == null) {
        type = Span.Identifier;
      }
      word = this.match(Line.SymbolRegex, type);
      if (!(word != null)) {
        this.fail("" + name + " must contain only letters, digits, _ or .");
      }
      word = word.toLowerCase();
      if (Dcpu.Reserved[word] || Dcpu.ReservedOp[word]) {
        this.fail("Reserved keyword: " + word);
      }
      return word;
    };

    Line.prototype.parseMacroArg = function() {
      var ch, inChar, inString, rv, start, _ref;
      inString = false;
      inChar = false;
      rv = "";
      while (!this.finished()) {
        if (((_ref = this.text[this.pos]) === ';' || _ref === ')' || _ref === ',') && !inString && !inChar) {
          return rv;
        }
        start = this.pos;
        if (this.text[this.pos] === '\\' && this.pos + 1 < this.end) {
          rv += this.text[this.pos++];
          rv += this.text[this.pos++];
          this.addSpan(Span.StringEscape, start, this.pos);
        } else {
          ch = this.text[this.pos];
          rv += ch;
          if (ch === '"') {
            inString = !inString;
          }
          if (ch === "\'") {
            inChar = !inChar;
          }
          this.pos++;
          this.addSpan(Span.String, start, this.pos);
        }
      }
      if (inString) {
        this.fail("Expected closing \"");
      }
      if (inChar) {
        this.fail("Expected closing \'");
      }
      return rv;
    };

    return Line;

  })();

  Line.SymbolRegex = /^[a-zA-Z_.][a-zA-Z_.0-9]*/;

  exports.Span = Span;

  exports.Line = Line;

  Operand = (function() {

    function Operand(pos, code, expr) {
      this.pos = pos;
      this.code = code;
      this.expr = expr;
      this.immediate = null;
      this.compacting = false;
      this.foldConstants();
    }

    Operand.prototype.toString = function() {
      if (this.immediate != null) {
        return "<" + this.code + ", " + this.immediate + ">";
      } else if (this.expr != null) {
        return "<" + this.code + ", " + (this.expr.toString()) + ">";
      } else {
        return "<" + this.code + ">";
      }
    };

    Operand.prototype.clone = function() {
      var rv;
      rv = new Operand(this.pos, this.code, this.expr);
      rv.immediate = this.immediate;
      rv.compacting = this.compacting;
      return rv;
    };

    Operand.prototype.resolvable = function(symtab) {
      if (symtab == null) {
        symtab = {};
      }
      if (this.expr != null) {
        return this.expr.resolvable(symtab);
      } else {
        return true;
      }
    };

    Operand.prototype.foldConstants = function(symtab) {
      if (symtab == null) {
        symtab = {};
      }
      if ((this.expr != null) && this.expr.resolvable(symtab)) {
        this.immediate = this.expr.evaluate(symtab) & 0xffff;
        return delete this.expr;
      }
    };

    Operand.prototype.checkCompact = function(symtab) {
      var value;
      if (this.compacting || this.code !== Operand.Immediate) {
        return false;
      }
      value = this.immediateValue(symtab);
      if (!(value != null)) {
        return false;
      }
      if (value === 0xffff || value < 31) {
        this.compacting = true;
        return true;
      } else {
        return false;
      }
    };

    Operand.prototype.pack = function(symtab) {
      var inline, value;
      value = this.immediateValue(symtab);
      if (this.compacting) {
        if (value != null) {
          inline = value === 0xffff ? 0x00 : 0x01 + value;
          return [Operand.ImmediateInline + inline, null];
        } else {
          return [0, null];
        }
      } else if ((this.expr != null) && !(value != null)) {
        return [this.code, this.expr];
      } else if (value != null) {
        return [this.code, value];
      } else {
        return [this.code, null];
      }
    };

    Operand.prototype.immediateValue = function(symtab) {
      if (this.immediate != null) {
        return this.immediate;
      }
      if ((this.expr != null) && this.expr.resolvable(symtab)) {
        return this.expr.evaluate(symtab) & 0xffff;
      } else {
        return null;
      }
    };

    return Operand;

  })();

  Operand.Register = 0x00;

  Operand.RegisterDereference = 0x08;

  Operand.RegisterIndex = 0x10;

  Operand.ImmediateDereference = 0x1e;

  Operand.Immediate = 0x1f;

  Operand.ImmediateInline = 0x20;

  exports.Operand = Operand;


  AssemblerOutput = (function() {

    function AssemblerOutput(errors, lines, symtab) {
      var i, line, size, _i, _ref;
      this.errors = errors;
      this.lines = lines;
      this.symtab = symtab;
      this.lineMap = [];
      for (i = _i = 0, _ref = this.lines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = this.lines[i];
        if (!(line != null)) {
          continue;
        }
        delete line.pline;
        size = line.data.length;
        if (size === 0) {
          continue;
        }
        this.lineMap.push({
          address: line.address,
          end: line.address + size,
          lineno: i
        });
      }
      this.lineMap.sort(function(a, b) {
        if (a.address > b.address) {
          return 1;
        } else {
          return -1;
        }
      });
    }

    AssemblerOutput.prototype.pack = function() {
      if (this.cachedPack != null) {
        return this.cachedPack;
      }
      if (this.errors.length > 0 || this.lines.length === 0) {
        return [];
      }
      this.cachedPack = this.lines[0].pack(this.lines);
      return this.cachedPack;
    };

    AssemblerOutput.prototype.memToLine = function(address) {
      var hi, line, lo, n;
      lo = 0;
      hi = this.lineMap.length;
      while (true) {
        if (lo >= hi) {
          return null;
        }
        n = lo + Math.floor((hi - lo) / 2);
        line = this.lineMap[n];
        if ((line.address <= address && address < line.end)) {
          return line.lineno;
        }
        if (address < line.address) {
          hi = n;
        } else {
          lo = n + 1;
        }
      }
    };

    AssemblerOutput.prototype.memToClosestLine = function(address) {
      var c, candidates, hi, line, lo, n, _i, _len,
        _this = this;
      lo = 0;
      hi = this.lineMap.length;
      while (true) {
        if (lo === hi) {
          candidates = [];
          if (hi < this.lineMap.length) {
            candidates.push({
              addr: this.lineMap[hi].address,
              lineno: this.lineMap[hi].lineno
            });
          }
          if (lo > 0) {
            candidates.push({
              addr: this.lineMap[lo - 1].end - 1,
              lineno: this.lineMap[lo - 1].lineno
            });
          }
          for (_i = 0, _len = candidates.length; _i < _len; _i++) {
            c = candidates[_i];
            c.distance = Math.abs(c.addr - address);
          }
          candidates.sort(function(a, b) {
            return a.distance - b.distance;
          });
          if (candidates.length === 0 || candidates[0].distance > 0x100) {
            return null;
          }
          return candidates[0].lineno;
        }
        n = lo + Math.floor((hi - lo) / 2);
        line = this.lineMap[n];
        if ((line.org <= address && address < line.end)) {
          return line.lineno;
        }
        if (address < line.address) {
          hi = n;
        } else {
          lo = Math.min(n + 1, hi);
        }
      }
    };

    AssemblerOutput.prototype.lineToMem = function(lineno) {
      if (lineno < 0 || lineno >= this.lines.length) {
        return null;
      }
      if (this.lines[lineno].data.length === 0) {
        return null;
      }
      return this.lines[lineno].address;
    };

    AssemblerOutput.prototype.createImage = function(memory) {
      var block, j, _i, _j, _len, _ref, _ref1, _ref2;
      if (memory == null) {
        memory = null;
      }
      if (!(memory != null)) {
        memory = new Array(0x10000);
        for (j = _i = 0; 0 <= 0x10000 ? _i < 0x10000 : _i > 0x10000; j = 0 <= 0x10000 ? ++_i : --_i) {
          memory[j] = 0;
        }
      }
      _ref = this.pack();
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        block = _ref[_j];
        [].splice.apply(memory, [(_ref1 = block.address), (block.address + block.data.length) - _ref1].concat(_ref2 = block.data)), _ref2;
      }
      return memory;
    };

    return AssemblerOutput;

  })();

  exports.AssemblerOutput = AssemblerOutput;








  ParsedLine = (function() {

    function ParsedLine(line, options) {
      this.line = line;
      this.options = options;
      this.label = null;
      this.op = null;
      this.opPos = null;
      this.directive = null;
      this.name = null;
      this.operands = [];
      this.data = [];
      this.expanded = null;
      this.macroArgOffsets = null;
    }

    ParsedLine.prototype.toString = function() {
      var _this = this;
      return [this.label != null ? ":" + this.label + " " : "", this.op != null ? this.op.toUpperCase() : "", this.directive != null ? "." + this.directive : "", this.name != null ? " " + this.name : ""].join("") + this.operands.map(function(x) {
        return " " + x.toString();
      }).join(",") + (this.expanded != null ? "{" + this.expanded.map(function(x) {
        return " " + x.toString();
      }).join(";") + " }" : "");
    };

    ParsedLine.prototype.clone = function() {
      var rv;
      rv = new ParsedLine(this.line);
      rv.label = this.label;
      rv.op = this.op;
      rv.opPos = this.opPos;
      rv.directive = this.directive;
      rv.name = this.name;
      rv.operands = this.operands.map(function(x) {
        return x.clone();
      });
      rv.data = this.data.map(function(x) {
        return x;
      });
      rv.expanded = this.expanded != null ? this.expanded.map(function(x) {
        return x.clone();
      }) : null;
      return rv;
    };

    ParsedLine.prototype.toHtml = function() {
      return this.line.toHtml();
    };

    ParsedLine.prototype.toDebug = function() {
      return this.line.toDebug();
    };

    ParsedLine.prototype.fail = function(message) {
      if (!this.options.ignoreErrors) {
        throw new AssemblerError(this.line.text, this.opPos.pos, message);
      }
    };

    ParsedLine.prototype.foldConstants = function(symtab) {
      var _i, _len, _ref,
        _this = this;
      _ref = this.operands;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        x.foldConstants(symtab);
      }
      return this.data = this.data.map(function(x) {
        if ((x instanceof Expression) && x.resolvable(symtab)) {
          return x.evaluate(symtab);
        } else {
          return x;
        }
      });
    };

    return ParsedLine;

  })();

  Macro = (function() {

    function Macro(name, fullname, parameters) {
      this.name = name;
      this.fullname = fullname;
      this.parameters = parameters;
      this.textLines = [];
      this.onError = null;
      this.parameterMatchers = this.parameters.map(function(p) {
        return new RegExp("\\b" + p + "\\b", "g");
      });
    }

    Macro.prototype.invoke = function(parser, pline, args) {
      var argOffset, argOffsets, expanded, i, newTextLines, plines, text, _i, _j, _k, _len, _len1, _len2, _ref;
      parser.debug("  macro expansion of ", this.fullname, ":");
      newTextLines = (function() {
        var _i, _j, _len, _ref, _ref1, _results,
          _this = this;
        _ref = this.textLines;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          text = _ref[_i];
          argOffsets = [];
          for (i = _j = 0, _ref1 = args.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            text = text.replace(this.parameterMatchers[i], function(original, offset) {
              argOffsets.push({
                left: offset,
                right: offset + args[i].length,
                arg: i
              });
              return args[i];
            });
          }
          parser.debug("  -- ", text);
          _results.push([text, argOffsets]);
        }
        return _results;
      }).call(this);
      parser.debug("  --.");
      parser.setLabelPrefix(this.name + "." + Date.now() + "." + Math.floor(Math.random() * 1000000.0));
      plines = [];
      try {
        for (_i = 0, _len = newTextLines.length; _i < _len; _i++) {
          _ref = newTextLines[_i], text = _ref[0], argOffsets = _ref[1];
          try {
            pline = parser.parseLine(text);
          } catch (e) {
            if (e.type !== "AssemblerError") {
              throw e;
            }
            parser.debug("  error in macro invocation: pos=", e.pos, " args=", argOffsets, " reason=", e.reason);
            if (this.onError != null) {
              e.setReason(this.onError);
            }
            for (_j = 0, _len1 = argOffsets.length; _j < _len1; _j++) {
              argOffset = argOffsets[_j];
              if (e.pos >= argOffset.left && e.pos <= argOffset.right) {
                throw new AssemblerError(pline.line.text, pline.macroArgIndexes[argOffset.arg], e.reason);
              }
            }
            throw new AssemblerError(pline.line.text, (args.length > 0 ? pline.macroArgIndexes[0] : 0), e.reason);
          }
          pline.macroArgOffsets = argOffsets;
          if (pline.directive != null) {
            pline.line.fail("Macros can't have directives in them");
          }
          if (pline.expanded != null) {
            expanded = pline.expanded;
            delete pline.expanded;
            if (pline.label != null) {
              plines.push(pline);
            }
            for (_k = 0, _len2 = expanded.length; _k < _len2; _k++) {
              x = expanded[_k];
              plines.push(x);
            }
          } else {
            plines.push(pline);
          }
        }
      } finally {
        parser.clearLabelPrefix();
      }
      parser.debug("  macro expansion of ", this.fullname, " complete: ", plines.length, " lines");
      return plines;
    };

    return Macro;

  })();

  Parser = (function() {

    Parser.prototype.DelimiterRegex = /^(\)|,|\])/;

    Parser.prototype.UnaryRegex = /^(\+|\-)/;

    Parser.prototype.NumberRegex = /^[0-9]+/;

    Parser.prototype.HexRegex = /^0x[0-9a-fA-F]+/;

    Parser.prototype.BinaryRegex = /^0b[01]+/;

    Parser.prototype.LabelRegex = /^([a-zA-Z_.][a-zA-Z_.0-9]*|\$)/;

    Parser.prototype.OperatorRegex = /^(\*|\/|%|\+|\-|<<|>>|\&|\^|\||<\=|>\=|<|>|==|!=)/;

    Parser.prototype.Binary = {
      '*': 10,
      '/': 10,
      '%': 10,
      '+': 9,
      '-': 9,
      '<<': 8,
      '>>': 8,
      '&': 7,
      '^': 6,
      '|': 5,
      '<': 4,
      '>': 4,
      '<=': 4,
      '>=': 4,
      '==': 4,
      '!=': 4
    };

    function Parser() {
      this.reset();
    }

    Parser.prototype.reset = function() {
      this.macros = {};
      this.inMacro = null;
      this.ifStack = [];
      this.ignoring = false;
      this.constants = {};
      this.lastLabel = null;
      this.labelPrefix = null;
      return this.labelStack = [];
    };

    Parser.prototype.debug = function() {
      var item, list, slist;
      list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this["debugger"] == null) {
        return;
      }
      slist = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          item = list[_i];
          switch (typeof item) {
            case 'string':
              _results.push(item.toString());
              break;
            default:
              _results.push(pp(item));
          }
        }
        return _results;
      })();
      return this["debugger"](slist.join(""));
    };

    Parser.prototype.fixLabel = function(label, save) {
      if (save == null) {
        save = false;
      }
      if (label[0] === ".") {
        if (this.labelPrefix != null) {
          label = this.labelPrefix + label;
        } else if (this.lastLabel != null) {
          label = this.lastLabel + label;
        }
      } else {
        if (save) {
          this.lastLabel = label;
        }
      }
      return label;
    };

    Parser.prototype.setLabelPrefix = function(prefix) {
      this.labelStack.push([this.lastLabel, this.labelPrefix]);
      this.lastLabel = null;
      return this.labelPrefix = prefix;
    };

    Parser.prototype.clearLabelPrefix = function() {
      var _ref;
      return _ref = this.labelStack.pop(), this.lastLabel = _ref[0], this.labelPrefix = _ref[1], _ref;
    };

    Parser.prototype.parseLine = function(text, lineNumber, options) {
      var expr, line, name, pline, sol;
      if (lineNumber == null) {
        lineNumber = 0;
      }
      if (options == null) {
        options = {};
      }
      this.debug("+ parse: ", lineNumber, ": ", text);
      line = new Line(text, options);
      pline = new ParsedLine(line, options);
      pline.lineNumber = lineNumber;
      line.skipWhitespace();
      if (line.finished()) {
        return pline;
      }
      sol = line.mark();
      if (line.scan("#", Span.Directive) || line.scan(".", Span.Directive)) {
        if (this.parseDirective(line, pline)) {
          return pline;
        }
        line.rewind(sol);
      }
      if (this.ignoring) {
        return pline;
      }
      if (line.scan("}", Span.Directive)) {
        if (!this.inMacro) {
          line.fail("Unexpected end of macro");
          return pline;
        }
        this.debug("  finished defining macro ", this.inMacro);
        this.inMacro = false;
        line.skipWhitespace();
        if (!line.finished()) {
          line.fail("Unexpected content after end of macro");
        }
        return pline;
      }
      if (this.inMacro) {
        this.macros[this.inMacro].textLines.push(text);
        return pline;
      }
      if (line.scan(":", Span.Label)) {
        pline.label = line.parseWord("Label", Span.Label);
        pline.label = this.fixLabel(pline.label, true);
        line.skipWhitespace();
      }
      if (line.finished()) {
        return pline;
      }
      pline.opPos = line.mark();
      pline.op = line.parseWord("Operation name", Span.Instruction);
      if (pline.op === "equ") {
        line.rewind(pline.opPos);
        line.scanAssert("equ", Span.Directive);
        line.skipWhitespace();
        expr = this.parseExpression(line);
        if (!(pline.label != null)) {
          line.pointTo(pline.opPos);
          line.fail("EQU must be a directive or on a line with a label");
          return pline;
        }
        name = pline.label;
        delete pline.label;
        delete pline.op;
        this.constants[name] = expr;
        this.constants[name].lineNumber = pline.lineNumber;
        line.skipWhitespace();
        if (!line.finished()) {
          line.fail("Unexpected content after definition");
        }
        return pline;
      }
      if (pline.op === "dat") {
        this.parseData(line, pline);
        return pline;
      }
      if (pline.op === "org") {
        line.rewind(pline.opPos);
        delete pline.op;
        line.scanAssert("org", Span.Directive);
        pline.directive = "org";
        this.parseOrgDirective(line, pline);
        return pline;
      }
      line.skipWhitespace();
      if (line.scan("=", Span.Operator)) {
        line.rewind(pline.opPos);
        delete pline.op;
        name = line.parseWord("Constant name", Span.Identifier);
        line.skipWhitespace();
        line.scanAssert("=", Span.Operator);
        line.skipWhitespace();
        this.constants[name] = this.parseExpression(line);
        this.constants[name].lineNumber = pline.lineNumber;
        line.skipWhitespace();
        if (!line.finished()) {
          line.fail("Unexpected content after definition");
        }
        return pline;
      }
      if (!(Dcpu.BinaryOp[pline.op] != null) && !(Dcpu.SpecialOp[pline.op] != null)) {
        line.rewind(pline.opPos);
        delete pline.op;
        return this.parseMacroCall(line, pline);
      }
      pline.operands = [];
      while (!line.finished()) {
        pline.operands.push(this.parseOperand(line, pline.operands.length === 0));
        line.skipWhitespace();
        if (!line.finished()) {
          line.scanAssert(",", Span.Operator);
          line.skipWhitespace();
        }
      }
      if (Dcpu.BinaryOp[pline.op] != null) {
        if (pline.operands.length !== 2) {
          pline.fail("" + (pline.op.toUpperCase()) + " requires 2 arguments");
        }
      } else if (Dcpu.SpecialOp[pline.op] != null) {
        if (pline.operands.length !== 1) {
          pline.fail("" + (pline.op.toUpperCase()) + " requires 1 argument");
        }
      } else {
        pline.fail("Unknown instruction: " + pline.op);
      }
      return pline;
    };

    Parser.prototype.parseExpression = function(line, precedence) {
      var left, m, newPrecedence, op, right;
      if (precedence == null) {
        precedence = 0;
      }
      line.skipWhitespace();
      if (line.finished()) {
        line.fail("Expected expression");
      }
      left = this.parseUnary(line);
      while (true) {
        line.skipWhitespace();
        if (line.finished() || line.matchAhead(Parser.prototype.DelimiterRegex)) {
          return left;
        }
        m = line.mark();
        op = line.match(Parser.prototype.OperatorRegex, Span.Operator);
        if (!(op != null)) {
          line.fail("Unknown operator (try: + - * / % << >> & ^ |)");
          return left;
        }
        newPrecedence = Parser.prototype.Binary[op];
        if (newPrecedence <= precedence) {
          line.rewind(m);
          return left;
        }
        right = this.parseExpression(line, newPrecedence);
        left = Expression.prototype.Binary(line.text, m.pos, op, left, right);
      }
    };

    Parser.prototype.parseUnary = function(line) {
      var expr, op, start;
      start = line.pos;
      op = line.match(Parser.prototype.UnaryRegex, Span.Operator);
      if (op != null) {
        expr = this.parseAtom(line);
        return Expression.prototype.Unary(line.text, start, op, expr);
      } else {
        return this.parseAtom(line);
      }
    };

    Parser.prototype.parseAtom = function(line) {
      var atom, ch, m;
      line.skipWhitespace();
      if (line.finished()) {
        line.fail("Value expected (operand or expression)");
      }
      m = line.mark();
      if (line.scan("(", Span.Operator)) {
        atom = this.parseExpression(line);
        line.skipWhitespace();
        if (line.finished() || (!line.scan(")", Span.Operator))) {
          line.fail("Missing ) on expression");
        }
        return atom;
      }
      if (line.scan("'", Span.String)) {
        ch = line.parseChar();
        line.scanAssert("'", Span.String);
        return Expression.prototype.Literal(line.text, m.pos, ch.charCodeAt(0));
      }
      if (line.scan("%", Span.Register)) {
        x = line.match(Dcpu.RegisterRegex, Span.Register);
        if (!(x != null)) {
          line.fail("Expected register name");
        }
        return Expression.prototype.Register(line.text, m.pos, x != null ? x.toLowerCase() : void 0);
      }
      x = line.match(Parser.prototype.HexRegex, Span.Number);
      if (x != null) {
        return Expression.prototype.Literal(line.text, m.pos, parseInt(x, 16));
      }
      x = line.match(Parser.prototype.BinaryRegex, Span.Number);
      if (x != null) {
        return Expression.prototype.Literal(line.text, m.pos, parseInt(x.slice(2), 2));
      }
      x = line.match(Parser.prototype.NumberRegex, Span.Number);
      if (x != null) {
        return Expression.prototype.Literal(line.text, m.pos, parseInt(x, 10));
      }
      x = line.match(Dcpu.RegisterRegex, Span.Register);
      if (x != null) {
        return Expression.prototype.Register(line.text, m.pos, x.toLowerCase());
      }
      x = line.match(Parser.prototype.LabelRegex, Span.Identifier);
      if (x != null) {
        return Expression.prototype.Label(line.text, m.pos, this.fixLabel(x, false));
      }
      line.pointTo(m);
      return line.fail("Expected expression");
    };

    Parser.prototype.parseOperand = function(line, destination) {
      var code, dereference, expr, inPick, m, op, register;
      if (destination == null) {
        destination = false;
      }
      this.debug("  parse operand: dest=", destination, " pos=", line.pos);
      m = line.mark();
      dereference = false;
      inPick = false;
      if (line.scan("[", Span.Operator)) {
        dereference = true;
      } else if (line.scan("pick", Span.Register)) {
        inPick = true;
      }
      expr = this.parseExpression(line);
      this.debug("  parse operand: expr=", expr);
      if (dereference) {
        line.scanAssert("]", Span.Operator);
      }
      if (inPick) {
        return new Operand(m.pos, Dcpu.Specials["pick"], expr);
      }
      if (expr.register != null) {
        if (Dcpu.Specials[expr.register] != null) {
          if (dereference) {
            line.pointTo(m);
            line.fail("You can't dereference " + (expr.toString()));
          }
          if ((destination && expr.register === "pop") || ((!destination) && expr.register === "push")) {
            line.pointTo(m);
            line.fail("You can't use " + (expr.toString()) + " in this position");
          }
          return new Operand(m.pos, Dcpu.Specials[expr.register]);
        }
        code = dereference ? Operand.RegisterDereference : Operand.Register;
        return new Operand(m.pos, code + Dcpu.Registers[expr.register]);
      }
      if (dereference && (expr.binary != null) && ((expr.left.register != null) || (expr.right.register != null))) {
        if (expr.binary === '+' || (expr.binary === '-' && (expr.left.register != null))) {
          register = expr.left.register != null ? expr.left.register : expr.right.register;
          if (!(Dcpu.Registers[register] != null)) {
            line.pointTo(m);
            line.fail("You can't use " + (register.toUpperCase()) + " in [R+n] form");
          }
          op = expr.binary;
          expr = expr.left.register != null ? expr.right : expr.left;
          if (op === '-') {
            expr = Expression.prototype.Unary(expr.text, expr.pos, '-', expr);
          }
          return new Operand(m.pos, Operand.RegisterIndex + Dcpu.Registers[register], expr);
        }
        line.pointTo(m);
        line.fail("Only a register +/- a constant is allowed");
      }
      return new Operand(m.pos, (dereference ? Operand.ImmediateDereference : Operand.Immediate), expr);
    };

    Parser.prototype.parseData = function(line, pline) {
      var ch, i, inWord, m, rom, s, word, _i, _j, _ref, _ref1, _results;
      delete pline.op;
      pline.data = [];
      line.skipWhitespace();
      _results = [];
      while (!line.finished()) {
        m = line.mark();
        if (line.scanAhead('"')) {
          s = line.parseString();
          for (i = _i = 0, _ref = s.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            pline.data.push(Expression.prototype.Literal(line.text, m.pos, s.charCodeAt(i)));
          }
        } else if (line.scanAhead('p"') || line.scanAhead('r"')) {
          if (line.scan("r", Span.String)) {
            rom = true;
          } else {
            line.scan("p", Span.String);
          }
          s = line.parseString();
          word = 0;
          inWord = false;
          for (i = _j = 0, _ref1 = s.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            ch = s.charCodeAt(i);
            if (rom && i === s.length - 1) {
              ch |= 0x80;
            }
            if (inWord) {
              pline.data.push(Expression.prototype.Literal(line.text, m.pos, word | ch));
            } else {
              word = ch << 8;
            }
            inWord = !inWord;
          }
          if (inWord) {
            pline.data.push(Expression.prototype.Literal(line.text, m.pos, word));
          }
        } else {
          pline.data.push(this.parseExpression(line));
        }
        line.skipWhitespace();
        if (line.scan(",", Span.Operator)) {
          _results.push(line.skipWhitespace());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Parser.prototype.parseDirective = function(line, pline) {
      var m, _ref;
      m = line.mark();
      pline.directive = line.parseWord("Directive", Span.Directive);
      line.skipWhitespace();
      if ((_ref = pline.directive) === "if" || _ref === "else" || _ref === "endif") {
        if (this.inMacro) {
          return false;
        }
        switch (pline.directive) {
          case "if":
            this.parseIfDirective(line, pline);
            break;
          case "else":
            this.parseElseDirective(line, pline);
            break;
          case "endif":
            this.parseEndifDirective(line, pline);
        }
        return true;
      }
      if (this.ignoring) {
        return;
      }
      switch (pline.directive) {
        case "macro":
          this.parseMacroDirective(line, pline);
          break;
        case "define":
        case "equ":
          this.parseDefineDirective(line, pline);
          break;
        case "org":
          this.parseOrgDirective(line, pline);
          break;
        case "onerror":
          this.parseOnErrorDirective(line, pline);
          break;
        default:
          line.pointTo(m);
          line.fail("Unknown directive: " + directive);
      }
      return true;
    };

    Parser.prototype.parseDefineDirective = function(line, pline) {
      var name;
      delete pline.directive;
      name = line.parseWord("Definition name");
      line.skipWhitespace();
      this.constants[name] = this.parseExpression(line);
      this.constants[name].lineNumber = pline.lineNumber;
      line.skipWhitespace();
      if (!line.finished()) {
        return this.fail("Unexpected content after definition");
      }
    };

    Parser.prototype.parseOrgDirective = function(line, pline) {
      line.skipWhitespace();
      pline.data.push(this.parseExpression(line).evaluate());
      line.skipWhitespace();
      if (!line.finished()) {
        return this.fail("Unexpected content after origin");
      }
    };

    Parser.prototype.parseMacroDirective = function(line, pline) {
      var fullname, m, parameters;
      m = line.mark();
      pline.name = line.parseWord("Macro name");
      line.skipWhitespace();
      parameters = this.parseMacroParameters(line);
      line.skipWhitespace();
      line.scanAssert("{", Span.Directive);
      fullname = "" + pline.name + "(" + parameters.length + ")";
      if (this.macros[fullname] != null) {
        line.pointTo(m);
        line.fail("Duplicate definition of " + fullname);
      }
      this.macros[fullname] = new Macro(pline.name, fullname, parameters);
      if (!(this.macros[pline.name] != null)) {
        this.macros[pline.name] = [];
      }
      this.macros[pline.name].push(parameters.length);
      this.inMacro = fullname;
      return this.debug("  defining macro ", fullname);
    };

    Parser.prototype.parseMacroParameters = function(line) {
      var args;
      args = [];
      if (!line.scan("(", Span.Directive)) {
        return [];
      }
      line.skipWhitespace();
      while (!line.finished()) {
        if (line.scan(")", Span.Directive)) {
          return args;
        }
        args.push(line.parseWord("Argument name"));
        line.skipWhitespace();
        if (line.scan(",", Span.Directive)) {
          line.skipWhitespace();
        }
      }
      return line.fail("Expected )");
    };

    Parser.prototype.parseMacroCall = function(line, pline) {
      var argIndexes, args, m, name, _ref,
        _this = this;
      m = line.mark();
      name = line.parseWord("Macro name", Span.Instruction);
      line.skipWhitespace();
      if (line.scan("(", Span.Operator)) {
        line.skipWhitespace();
      }
      _ref = this.parseMacroArgs(line), args = _ref[0], argIndexes = _ref[1];
      pline.macroArgIndexes = argIndexes;
      args = args.map(function(x) {
        if (x[0] === ".") {
          return _this.fixLabel(x);
        } else {
          return x;
        }
      });
      if (!this.macros[name]) {
        line.pointTo(m);
        line.fail("Unknown macro '" + name + "'");
      } else if (this.macros[name].indexOf(args.length) < 0) {
        line.pointTo(m);
        line.fail("Macro '" + name + "' requires " + (this.macros[name].join(' or ')) + " arguments");
      } else {
        pline.expanded = this.macros["" + name + "(" + args.length + ")"].invoke(this, pline, args);
      }
      return pline;
    };

    Parser.prototype.parseMacroArgs = function(line) {
      var argIndexes, args, index;
      args = [];
      argIndexes = [];
      line.skipWhitespace();
      while (!line.finished()) {
        if (line.scan(")", Span.Operator)) {
          return [args, argIndexes];
        }
        index = line.pos;
        args.push(line.parseMacroArg());
        argIndexes.push(index);
        line.scan(",", Span.Operator);
        line.skipWhitespace();
      }
      return [args, argIndexes];
    };

    Parser.prototype.parseIfDirective = function(line, pline) {
      var expr, m;
      line.skipWhitespace();
      m = line.mark();
      expr = this.parseExpression(line);
      if (!line.finished()) {
        line.fail("Unexpected content after IF");
      }
      if (!expr.resolvable(this.constants)) {
        line.pointTo(m);
        line.fail("IF expression must use only constants");
      }
      expr = expr.evaluate(this.constants);
      this.ignoring = expr === 0;
      return this.ifStack.push(this.ignoring);
    };

    Parser.prototype.parseElseDirective = function(line, pline) {
      line.skipWhitespace();
      if (!line.finished()) {
        line.fail("Unexpected content after ELSE");
      }
      if (this.ifStack.length === 0) {
        line.fail("Dangling ELSE");
      }
      this.ignoring = !this.ignoring;
      this.ifStack.pop();
      return this.ifStack.push(this.ignoring);
    };

    Parser.prototype.parseEndifDirective = function(line, pline) {
      line.skipWhitespace();
      if (!line.finished()) {
        line.fail("Unexpected content after ENDIF");
      }
      if (this.ifStack.length === 0) {
        line.fail("Dangling ENDIF");
      }
      this.ifStack.pop();
      if (this.ifStack.length > 0) {
        return this.ignoring = this.ifStack[this.ifStack.length - 1];
      }
    };

    Parser.prototype.parseOnErrorDirective = function(line, pline) {
      if (!(this.inMacro != null)) {
        line.fail("Can only use .onerror inside macros");
      }
      line.skipWhitespace();
      this.macros[this.inMacro].onError = line.parseString();
      if (!line.finished()) {
        return line.fail("Unexpected content after .onerror");
      }
    };

    return Parser;

  })();

  exports.Line = Line;

  exports.Macro = Macro;

  exports.Parser = Parser;

  PrettyPrinter = (function() {

    function PrettyPrinter() {}

    PrettyPrinter.prototype.colors = ["37", "33;1", "33", "31", "35", "34;1", "36", "32"];

    PrettyPrinter.prototype.inColor = function(s, colorIndex) {
      colorIndex %= 8;
      return "\u001b[" + this.colors[colorIndex] + "m" + s + "\u001b[0m";
    };

    PrettyPrinter.prototype.dump = function(obj, colorIndex) {
      if (colorIndex == null) {
        colorIndex = 0;
      }
      if (obj === null) {
        return this.inColor("null", colorIndex);
      }
      switch (typeof obj) {
        case 'undefined':
          return this.inColor("undefined", colorIndex);
        case 'string':
          return this.inColor(this.dumpString(obj), colorIndex);
        case 'number':
          if (obj < 16) {
            return this.inColor(obj.toString(10), colorIndex);
          } else {
            return this.inColor("0x" + obj.toString(16), colorIndex);
          }
          break;
        case 'object':
          if (obj instanceof Array) {
            return this.dumpArray(obj, colorIndex + 1);
          } else if (obj instanceof RegExp) {
            return this.inColor(obj.toString(), colorIndex);
          } else {
            return this.dumpObject(obj, colorIndex + 1);
          }
          break;
        default:
          return this.inColor(obj.toString(), colorIndex);
      }
    };

    PrettyPrinter.prototype.dumpArray = function(obj, colorIndex) {
      var first, out, _i, _len;
      first = true;
      out = this.inColor("[", colorIndex);
      for (_i = 0, _len = obj.length; _i < _len; _i++) {
        x = obj[_i];
        if (!first) {
          out += this.inColor(",", colorIndex);
        }
        out += this.inColor(" ", colorIndex) + this.dump(x, colorIndex);
        first = false;
      }
      out += this.inColor(" ]", colorIndex);
      return out;
    };

    PrettyPrinter.prototype.dumpObject = function(obj, colorIndex) {
      var first, k, out, v;
      first = true;
      out = this.inColor("{", colorIndex);
      for (k in obj) {
        v = obj[k];
        if (typeof obj[k] !== 'function') {
          if (!first) {
            out += this.inColor(",", colorIndex);
          }
          out += this.inColor(" " + k + ": ", colorIndex) + this.dump(v, colorIndex);
          first = false;
        }
      }
      return out + this.inColor(" }", colorIndex);
    };

    PrettyPrinter.prototype.dumpString = function(s) {
      var ch, i, out, _i, _ref;
      out = "";
      for (i = _i = 0, _ref = s.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        ch = s.charCodeAt(i);
        if (ch < 32 || ch > 127) {
          hex = ch.toString(16);
          while (hex.length < 4) {
            hex = "0" + hex;
          }
          out += "\\u" + hex;
        } else {
          out += s[i];
        }
      }
      return "\"" + out + "\"";
    };

    return PrettyPrinter;

  })();

  prettyPrinter = new PrettyPrinter();

  pp = function(x) {
    return prettyPrinter.dump(x);
  };

  exports.prettyPrinter = prettyPrinter;

  exports.pp = pp;

}).call(this);
var d16bunny = exports; delete exports;
