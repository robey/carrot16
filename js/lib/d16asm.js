var exports = {};
// Generated by CoffeeScript 1.3.3
(function() {
  var Assembler, AssemblerError, AssemblerOutput, Dcpu, Expression, PrettyPrinter, prettyPrinter, x,
    __slice = [].slice;






  Assembler = (function() {

    Assembler.prototype.Binary = {
      '*': 10,
      '/': 10,
      '%': 10,
      '+': 9,
      '-': 9,
      '<<': 8,
      '>>': 8,
      '&': 7,
      '^': 6,
      '|': 5
    };

    Assembler.prototype.OperandRegex = /^[A-Za-z_.0-9]+/;

    Assembler.prototype.NumberRegex = /^[0-9]+$/;

    Assembler.prototype.HexRegex = /^0x[0-9a-fA-F]+$/;

    Assembler.prototype.BinaryRegex = /^0b[01]+$/;

    Assembler.prototype.LabelRegex = /^[a-zA-Z_.][a-zA-Z_.0-9]*$/;

    Assembler.prototype.SymbolRegex = /^[a-zA-Z_.][a-zA-Z_.0-9]*/;

    function Assembler(logger) {
      this.logger = logger;
      this.reset();
    }

    Assembler.prototype.reset = function() {
      this.text = "";
      this.pos = 0;
      this.end = 0;
      this.inMacro = false;
      this.vars = {};
      this.macros = {};
      return this.symtab = {};
    };

    Assembler.prototype.debug = function() {
      var item, list, slist;
      list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this["debugger"] == null) {
        return;
      }
      slist = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          item = list[_i];
          switch (typeof item) {
            case 'string':
              _results.push(item.toString());
              break;
            default:
              _results.push(prettyPrinter.dump(item));
          }
        }
        return _results;
      })();
      return this["debugger"](slist.join(""));
    };

    Assembler.prototype.setText = function(text) {
      this.text = text;
      this.pos = 0;
      return this.end = text.length;
    };

    Assembler.prototype.fail = function(loc, message) {
      throw new AssemblerError(this.text, loc, message);
    };

    Assembler.prototype.skipWhitespace = function() {
      var c;
      c = this.text[this.pos];
      while (this.pos < this.end && (c === " " || c === "\t" || c === "\r" || c === "\n")) {
        c = this.text[++this.pos];
      }
      if (c === ';') {
        return this.end = this.pos;
      }
    };

    Assembler.prototype.parseWord = function(name) {
      var loc, m, word;
      loc = this.pos;
      m = Assembler.prototype.SymbolRegex.exec(this.text.slice(this.pos));
      if (!(m != null)) {
        this.fail(loc, name + " must contain only letters, digits, _ or .");
      }
      word = m[0].toLowerCase();
      this.pos += word.length;
      if (Dcpu.Reserved[word] || Dcpu.ReservedOp[word]) {
        this.fail(loc, "Reserved keyword: " + word);
      }
      return word;
    };

    Assembler.prototype.unquoteChar = function(text, pos, end) {
      var rv;
      rv = (function() {
        if (text[pos] === '\\' && pos + 1 < end) {
          switch (text[++pos]) {
            case 'n':
              return "\n";
            case 'r':
              return "\r";
            case 't':
              return "\t";
            case 'z':
              return "\u0000";
            case 'x':
              if (pos + 2 < end) {
                pos += 2;
                return String.fromCharCode(parseInt(text.slice(pos - 1, pos + 1), 16));
              } else {
                return "\\x";
              }
              break;
            default:
              return "\\" + text[pos];
          }
        } else {
          return text[pos];
        }
      })();
      return [rv, pos + 1];
    };

    Assembler.prototype.parseAtom = function() {
      var atom, ch, loc, operand, register, _ref;
      this.skipWhitespace();
      if (this.pos === this.end) {
        this.fail(this.pos, "Value expected (operand or expression)");
      }
      loc = this.pos;
      if (this.text[this.pos] === "(") {
        this.pos++;
        atom = this.parseExpression(0);
        this.skipWhitespace();
        if (this.pos === this.end || this.text[this.pos] !== ")") {
          this.fail(this.pos, "Missing ) on expression");
        }
        this.pos++;
        return atom;
      } else if (this.text[this.pos] === "'") {
        _ref = this.unquoteChar(this.text, this.pos + 1, this.end), ch = _ref[0], this.pos = _ref[1];
        if (this.pos === this.end || this.text[this.pos] !== "'") {
          this.fail(this.pos, "Expected ' to close literal char");
        }
        this.pos++;
        return Expression.prototype.Literal(this.text, loc, ch.charCodeAt(0));
      } else if (this.text[this.pos] === "%") {
        this.pos++;
        register = Dcpu.Registers[this.text[this.pos].toLowerCase()];
        if (!(register != null)) {
          this.fail(this.pos, "Expected register name");
        }
        this.pos++;
        return Expression.prototype.Register(this.text, loc, register);
      } else {
        operand = Assembler.prototype.OperandRegex.exec(this.text.slice(this.pos, this.end));
        if (!(operand != null)) {
          this.fail(this.pos, "Expected operand value");
        }
        operand = operand[0].toLowerCase();
        this.pos += operand.length;
        if (this.vars[operand] != null) {
          operand = this.vars[operand].toLowerCase();
        }
        if (Assembler.prototype.NumberRegex.exec(operand) != null) {
          return Expression.prototype.Literal(this.text, loc, parseInt(operand, 10));
        } else if (Assembler.prototype.HexRegex.exec(operand) != null) {
          return Expression.prototype.Literal(this.text, loc, parseInt(operand, 16));
        } else if (Assembler.prototype.BinaryRegex.exec(operand) != null) {
          return Expression.prototype.Literal(this.text, loc, parseInt(operand.slice(2), 2));
        } else if (Dcpu.Registers[operand] != null) {
          return Expression.prototype.Register(this.text, loc, Dcpu.Registers[operand]);
        } else if (Assembler.prototype.LabelRegex.exec(operand) != null) {
          return Expression.prototype.Label(this.text, loc, operand);
        } else {
          return this.fail(loc, "Expected operand");
        }
      }
    };

    Assembler.prototype.parseUnary = function() {
      var expr, loc, op;
      if (this.pos < this.end && (this.text[this.pos] === "-" || this.text[this.pos] === "+")) {
        loc = this.pos;
        op = this.text[this.pos++];
        expr = this.parseAtom();
        return Expression.prototype.Unary(this.text, loc, op, expr);
      } else {
        return this.parseAtom();
      }
    };

    Assembler.prototype.parseExpression = function(precedence) {
      var left, loc, newPrecedence, op, right;
      this.skipWhitespace();
      if (this.pos === this.end) {
        this.fail(this.pos, "Expression expected");
      }
      left = this.parseUnary();
      while (true) {
        this.skipWhitespace();
        if (this.pos === this.end || this.text[this.pos] === ')' || this.text[this.pos] === ',' || this.text[this.pos] === ']') {
          return left;
        }
        op = this.text[this.pos];
        if (!Assembler.prototype.Binary[op]) {
          op += this.text[this.pos + 1];
        }
        if (!((newPrecedence = Assembler.prototype.Binary[op]) != null)) {
          this.fail(this.pos, "Unknown operator (try: + - * / % << >> & ^ |)");
        }
        if (newPrecedence <= precedence) {
          return left;
        }
        loc = this.pos;
        this.pos += op.length;
        right = this.parseExpression(newPrecedence);
        left = Expression.prototype.Binary(this.text, loc, op, left, right);
      }
    };

    Assembler.prototype.parseString = function() {
      var ch, rv, _ref;
      rv = "";
      this.pos++;
      while (this.pos < this.end && this.text[this.pos] !== '"') {
        _ref = this.unquoteChar(this.text, this.pos, this.end), ch = _ref[0], this.pos = _ref[1];
        rv += ch;
      }
      if (this.pos === this.end) {
        this.fail(this.pos, "Expected \" to close string");
      }
      this.pos++;
      return rv;
    };

    Assembler.prototype.parseOperand = function(destination) {
      var expr, inPick, inPointer, loc, register;
      this.debug("  parse operand: dest=", destination, " pos=", this.pos);
      loc = this.pos;
      inPointer = false;
      inPick = false;
      if (this.text[this.pos] === '[') {
        this.pos++;
        inPointer = true;
      } else if (this.pos + 4 < this.end && this.text.substr(this.pos, 4).toLowerCase() === "pick") {
        this.pos += 4;
        inPick = true;
      }
      expr = this.parseExpression(0);
      this.debug("  parse operand: expr=", expr);
      if (inPointer) {
        if (this.pos === this.end || this.text[this.pos] !== ']') {
          this.fail(this.pos, "Expected ]");
        }
        this.pos++;
      }
      if (inPick) {
        return {
          loc: loc,
          code: 0x1a,
          expr: expr
        };
      }
      if (expr.register != null) {
        return {
          loc: loc,
          code: (inPointer ? 0x08 : 0x00) + expr.register
        };
      }
      if ((expr.label != null) && Dcpu.Specials[expr.label]) {
        if (inPointer) {
          this.fail(loc, "You can't use a pointer to " + expr.label.toUpperCase());
        }
        if ((destination && expr.label === "pop") || ((!destination) && expr.label === "push")) {
          this.fail(loc, "You can't use " + expr.label.toUpperCase() + " in this position");
        }
        return {
          loc: loc,
          code: Dcpu.Specials[expr.label]
        };
      }
      if (inPointer && (expr.binary != null) && ((expr.left.register != null) || (expr.right.register != null))) {
        if (expr.binary !== '+') {
          this.fail(loc, "Only a value + register is allowed");
        }
        register = expr.left.register != null ? expr.left.register : expr.right.register;
        expr = expr.left.register != null ? expr.right : expr.left;
        return {
          loc: loc,
          code: 0x10 + register,
          expr: expr
        };
      }
      return {
        loc: loc,
        code: (inPointer ? 0x1e : 0x1f),
        expr: expr
      };
    };

    Assembler.prototype.resolveOperand = function(operand, large) {
      var value;
      if (large == null) {
        large = false;
      }
      this.debug("  resolve operand: ", operand);
      if (!(operand.expr != null)) {
        return true;
      }
      if (!operand.expr.resolvable(this.symtab)) {
        return false;
      }
      value = operand.expr.evaluate(this.symtab) & 0xffff;
      if (operand.code === 0x1f && (value === 0xffff || value < 31) && large) {
        operand.code = 0x20 + (value === 0xffff ? 0x00 : 0x01 + value);
      } else {
        operand.immediate = value;
      }
      delete operand.expr;
      return true;
    };

    Assembler.prototype.parseMacroDirective = function() {
      var argNames, fullname, loc, name;
      loc = this.pos;
      name = this.parseWord("Macro name");
      this.skipWhitespace();
      argNames = [];
      if (this.pos < this.end && this.text[this.pos] === '(') {
        this.pos++;
        this.skipWhitespace();
        while (this.pos < this.end && this.text[this.pos] !== ')') {
          if (this.text[this.pos] === ')') {
            break;
          }
          argNames.push(this.parseWord("Parameter name"));
          this.skipWhitespace();
          if (this.pos < this.end && this.text[this.pos] === ',') {
            this.pos++;
            this.skipWhitespace();
          }
        }
        if (this.pos === this.end) {
          this.fail(this.pos, "Expected )");
        }
        this.pos++;
      }
      this.skipWhitespace();
      if (this.pos === this.end || this.text[this.pos] !== '{') {
        this.fail(this.pos, "Expected { to start macro definition");
      }
      fullname = name + "(" + argNames.length + ")";
      if (this.macros[fullname] != null) {
        this.fail(loc, "Duplicate definition of " + fullname);
      }
      this.macros[fullname] = {
        name: fullname,
        lines: [],
        params: argNames
      };
      if (!(this.macros[name] != null)) {
        this.macros[name] = [];
      }
      this.macros[name].push(argNames.length);
      return this.inMacro = fullname;
    };

    Assembler.prototype.parseDefineDirective = function() {
      var name, value;
      name = this.parseWord("Definition name");
      this.skipWhitespace();
      value = this.parseExpression(0).evaluate();
      return this.symtab[name] = value;
    };

    Assembler.prototype.parseDirective = function() {
      var directive, loc;
      loc = this.pos;
      directive = this.parseWord("Directive");
      this.skipWhitespace();
      switch (directive) {
        case "macro":
          return this.parseMacroDirective();
        case "define":
          return this.parseDefineDirective();
        default:
          return this.fail(loc, "Unknown directive: " + directive);
      }
    };

    Assembler.prototype.parseMacroArgs = function() {
      var argn, args, inChar, inString;
      inString = false;
      inChar = false;
      args = [];
      argn = 0;
      while (this.pos < this.end) {
        if ((this.text[this.pos] === ';' || this.text[this.pos] === ')') && !inString && !inChar) {
          break;
        }
        if (!(args[argn] != null)) {
          args.push("");
        }
        if (this.text[this.pos] === '\\' && this.pos + 1 < this.end) {
          args[argn] += this.text[this.pos++];
          args[argn] += this.text[this.pos++];
        } else if (this.text[this.pos] === ',' && !inString && !inChar) {
          argn++;
          this.pos++;
          this.skipWhitespace();
        } else {
          args[argn] += this.text[this.pos];
          if (this.text[this.pos] === '"') {
            inString = !inString;
          }
          if (this.text[this.pos] === "\'") {
            inChar = !inChar;
          }
          this.pos++;
        }
      }
      if (inString) {
        this.fail(this.pos, "Expected closing \"");
      }
      if (inChar) {
        this.fail(this.pos, "Expected closing \'");
      }
      return args;
    };

    Assembler.prototype.parseMacroCall = function(line) {
      var args, i, k, macro, name, old_vars, v, x, _i, _ref;
      if (this.pos < this.end && this.text[this.pos] === '(') {
        this.pos++;
        this.skipWhitespace();
      }
      args = this.parseMacroArgs();
      name = line.op;
      delete line.op;
      if (this.macros[name].indexOf(args.length) < 0) {
        this.fail(0, "Macro '" + name + "' requires " + this.macros[name].join(" or ") + " arguments");
      }
      macro = this.macros[name + "(" + args.length + ")"];
      old_vars = this.vars;
      this.vars = {};
      for (k in old_vars) {
        v = old_vars[k];
        this.vars[k] = v;
      }
      for (i = _i = 0, _ref = args.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.vars[macro.params[i]] = args[i];
      }
      this.debug("  new vars: ", this.vars);
      line.expanded = (function() {
        var _j, _len, _ref1, _results;
        _ref1 = macro.lines;
        _results = [];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          x = _ref1[_j];
          _results.push(this.parseLine(x));
        }
        return _results;
      }).call(this);
      this.vars = old_vars;
      return line;
    };

    Assembler.prototype.parseData = function(line) {
      var ch, data, expr, i, inWord, s, word, _i, _j, _ref, _ref1;
      data = [];
      while (this.pos < this.end) {
        if (this.text[this.pos] === '"') {
          s = this.parseString();
          for (i = _i = 0, _ref = s.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            data.push(s.charCodeAt(i));
          }
        } else if (this.pos + 1 < this.end && this.text[this.pos] === 'p' && this.text[this.pos + 1] === '"') {
          this.pos++;
          s = this.parseString();
          word = 0;
          inWord = false;
          for (i = _j = 0, _ref1 = s.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            ch = s.charCodeAt(i);
            if (inWord) {
              data.push(word | ch);
            } else {
              word = ch << 8;
            }
            inWord = !inWord;
          }
          if (inWord) {
            data.push(word);
          }
        } else {
          expr = this.parseExpression(0);
          data.push(expr.resolvable(this.symtab) ? expr.evaluate(this.symtab) : expr);
        }
        this.skipWhitespace();
        if (this.pos < this.end && this.text[this.pos] === ',') {
          this.pos++;
          this.skipWhitespace();
        }
      }
      line.data = data;
      return line;
    };

    Assembler.prototype.parseLine = function(text) {
      var line, name, value;
      this.setText(text);
      this.skipWhitespace();
      line = {};
      if (this.pos === this.end) {
        return line;
      }
      if (this.inMacro) {
        if (this.text[this.pos] === '}') {
          this.inMacro = false;
        } else {
          this.macros[this.inMacro].lines.push(text);
        }
        return line;
      }
      if (this.text[this.pos] === '#') {
        this.pos++;
        this.parseDirective();
        return line;
      }
      if (this.text[this.pos] === ':') {
        this.pos++;
        line.label = this.parseWord("Label");
        this.skipWhitespace();
      }
      if (this.pos === this.end) {
        return line;
      }
      line.pos = this.pos;
      line.op = this.parseWord("Operation name");
      if (this.vars[line.op]) {
        line.op = this.vars[line.op];
      }
      this.skipWhitespace();
      if (this.text[this.pos] === '=') {
        name = line.op;
        delete line.op;
        this.pos++;
        this.skipWhitespace();
        value = this.parseExpression(0).evaluate();
        this.symtab[name] = value;
        return line;
      }
      if (this.macros[line.op]) {
        return this.parseMacroCall(line);
      }
      if (line.op === "dat") {
        return this.parseData(line);
      }
      line.operands = [];
      while (this.pos < this.end) {
        line.operands.push(this.parseOperand(line.operands.length === 0));
        this.skipWhitespace();
        if (this.pos < this.end && this.text[this.pos] === ',') {
          this.pos++;
          this.skipWhitespace();
        }
      }
      return line;
    };

    Assembler.prototype.compileLine = function(text, org) {
      this.debug("+ compile line @ ", org, ": ", text, " -- symtab: ", this.symtab);
      return this.compileParsedLine(this.parseLine(text), org);
    };

    Assembler.prototype.compileParsedLine = function(line, org) {
      var i, info, newinfo, x, _i, _j, _len, _ref, _ref1;
      this.debug("  parsed line: ", line);
      this.symtab["."] = org;
      if (line.label != null) {
        this.symtab[line.label] = org;
      }
      if (line.data != null) {
        return {
          data: line.data,
          org: org
        };
      }
      if (line.expanded != null) {
        info = {
          data: [],
          org: org
        };
        _ref = line.expanded;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          this.debug("  expand macro: ", x);
          if ((x.op != null) && x.op === "org") {
            this.fail(line.pos, "Sorry, you can't use ORG in a macro.");
          }
          newinfo = this.compileParsedLine(x, org);
          info.data = info.data.concat(newinfo.data);
          org += newinfo.data.size;
          this.debug("  finished macro expansion: ", newinfo);
        }
        return info;
      }
      if (!(line.op != null)) {
        return {
          data: [],
          org: org
        };
      }
      if (line.op === "org") {
        if (line.operands.length !== 1) {
          this.fail(line.pos, "ORG requires a single parameter");
        }
        if (!line.operands[0].expr.resolvable(this.symtab)) {
          this.fail(line.operands[0].pos, "ORG must be a constant expression with no forward references");
        }
        info = {
          org: line.operands[0].expr.evaluate(this.symtab),
          data: []
        };
        if (line.label != null) {
          this.symtab[line.label] = info.org;
        }
        return info;
      }
      if (line.op === "equ") {
        if (line.operands.length !== 1) {
          this.fail(line.pos, "EQU requires a single parameter");
        }
        if (!line.operands[0].expr.resolvable(this.symtab)) {
          this.fail(line.operands[0].pos, "EQU must be a constant expression with no forward references");
        }
        if (!(line.label != null)) {
          this.fail(line.pos, "EQU requires a label");
        }
        this.symtab[line.label] = line.operands[0].expr.evaluate(this.symtab);
        return {
          org: org,
          data: []
        };
      }
      if (line.op === "jmp") {
        if (line.operands.length !== 1) {
          this.fail(line.pos, "JMP requires a single parameter");
        }
        line.op = "set";
        this.setText("pc");
        line.operands.unshift(this.parseOperand(true));
        return this.compileParsedLine(line, org);
      }
      if (line.op === "brk") {
        if (line.operands.length !== 0) {
          this.fail(line.pos, "BRK has no parameters");
        }
        return this.compileLine("sub pc, 1", org);
      }
      if (line.op === "ret") {
        if (line.operands.length !== 0) {
          this.fail(line.pos, "RET has no parameters");
        }
        return this.compileLine("set pc, pop", org);
      }
      if (line.op === "bra") {
        if (line.operands.length !== 1) {
          this.fail(line.pos, "BRA requires a single parameter");
        }
        if (line.operands[0].code !== 0x1f) {
          this.fail(line.operands[0].loc, "BRA takes only an immediate value");
        }
        return {
          data: [line.operands[0]],
          org: org,
          branchFrom: org + 1
        };
      }
      info = {
        data: [0],
        org: org
      };
      if (line.operands.length > 0) {
        for (i = _j = _ref1 = line.operands.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; i = _ref1 <= 0 ? ++_j : --_j) {
          x = line.operands[i];
          this.resolveOperand(x, i === line.operands.length - 1);
          if (x.expr != null) {
            info.data.push(x.expr);
          }
          if (x.immediate != null) {
            info.data.push(x.immediate);
          }
        }
      }
      if (Dcpu.BinaryOp[line.op] != null) {
        if (line.operands.length !== 2) {
          this.fail(line.pos, line.op.toUpperCase() + " requires 2 parameters");
        }
        info.data[0] = (line.operands[1].code << 10) | (line.operands[0].code << 5) | Dcpu.BinaryOp[line.op];
      } else if (Dcpu.SpecialOp[line.op] != null) {
        if (line.operands.length !== 1) {
          this.fail(line.pos, line.op.toUpperCase() + " requires 1 parameter");
        }
        info.data[0] = (line.operands[0].code << 10) | (Dcpu.SpecialOp[line.op] << 5);
      } else {
        this.fail(line.pos, "Unknown instruction: " + line.op);
      }
      return info;
    };

    Assembler.prototype.resolveLine = function(info) {
      var dest, i, offset, opcode, _i, _ref;
      this.symtab["."] = info.org;
      if (info.branchFrom) {
        this.debug("  resolve bra: ", info);
        dest = info.data[0].expr.evaluate(this.symtab);
        offset = info.branchFrom - dest;
        if (offset < -30 || offset > 30) {
          this.fail(info.data[0].pos, "Short branch can only move 30 words away (here: " + Math.abs(offset) + ")");
        }
        opcode = offset < 0 ? Dcpu.BinaryOp.add : Dcpu.BinaryOp.sub;
        info.data[0] = ((Math.abs(offset) + 0x21) << 10) | (Dcpu.Specials.pc << 5) | opcode;
        delete info.branchFrom;
      }
      this.debug("  resolve: ", info);
      for (i = _i = 0, _ref = info.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (typeof info.data[i] === 'object') {
          info.data[i] = info.data[i].evaluate(this.symtab);
        }
      }
      return info;
    };

    Assembler.prototype.compile = function(lines, org, maxErrors) {
      var defaultValue, errorCount, giveUp, i, info, infos, j, line, process, _i, _j, _k, _ref, _ref1, _ref2,
        _this = this;
      if (org == null) {
        org = 0;
      }
      if (maxErrors == null) {
        maxErrors = 10;
      }
      infos = [];
      errorCount = 0;
      giveUp = false;
      defaultValue = {
        org: org,
        data: []
      };
      process = function(lineno, f) {
        var pos, reason;
        if (giveUp) {
          return defaultValue;
        }
        try {
          return f();
        } catch (e) {
          if (e.type !== "AssemblerError") {
            throw e;
          }
          pos = e.pos != null ? e.pos : 0;
          reason = e.reason != null ? e.reason : e.toString();
          _this.debug("  error on line ", lineno, " at ", pos, ": ", reason);
          _this.logger(lineno, pos, reason);
          errorCount++;
          if (errorCount >= maxErrors) {
            _this.debug("  too many errors");
            _this.logger(lineno, 0, "Too many errors; giving up.");
            giveUp = true;
          }
          return defaultValue;
        }
      };
      for (i = _i = 0, _ref = lines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = lines[i];
        info = process(i, function() {
          return _this.compileLine(line, org);
        });
        infos.push(info);
        org = info.org + info.data.length;
      }
      for (i = _j = 0, _ref1 = lines.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        info = infos[i];
        process(i, function() {
          return _this.resolveLine(info);
        });
        for (j = _k = 0, _ref2 = info.data.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
          if (typeof info.data[j] === 'object') {
            info.data[j] = 0;
          }
        }
      }
      return new AssemblerOutput(errorCount, infos, this.symtab);
    };

    return Assembler;

  })();

  exports.Assembler = Assembler;

  exports.AssemblerError = AssemblerError;

  Dcpu = {
    Registers: {
      "a": 0,
      "b": 1,
      "c": 2,
      "x": 3,
      "y": 4,
      "z": 5,
      "i": 6,
      "j": 7
    },
    RegisterNames: "ABCXYZIJ",
    Specials: {
      "push": 0x18,
      "pop": 0x18,
      "peek": 0x19,
      "pick": 0x1a,
      "sp": 0x1b,
      "pc": 0x1c,
      "ex": 0x1d
    },
    BinaryOp: {
      "set": 0x01,
      "add": 0x02,
      "sub": 0x03,
      "mul": 0x04,
      "mli": 0x05,
      "div": 0x06,
      "dvi": 0x07,
      "mod": 0x08,
      "mdi": 0x09,
      "and": 0x0a,
      "bor": 0x0b,
      "xor": 0x0c,
      "shr": 0x0d,
      "asr": 0x0e,
      "shl": 0x0f,
      "ifb": 0x10,
      "ifc": 0x11,
      "ife": 0x12,
      "ifn": 0x13,
      "ifg": 0x14,
      "ifa": 0x15,
      "ifl": 0x16,
      "ifu": 0x17,
      "adx": 0x1a,
      "sbx": 0x1b,
      "sti": 0x1e,
      "std": 0x1f
    },
    SpecialOp: {
      "jsr": 0x01,
      "hcf": 0x07,
      "int": 0x08,
      "iag": 0x09,
      "ias": 0x0a,
      "rfi": 0x0b,
      "iaq": 0x0c,
      "hwn": 0x10,
      "hwq": 0x11,
      "hwi": 0x12
    }
  };

  Dcpu.Reserved = ((function() {
    var _results;
    _results = [];
    for (x in Dcpu.Registers) {
      _results.push(x);
    }
    return _results;
  })()).concat((function() {
    var _results;
    _results = [];
    for (x in Dcpu.Specials) {
      _results.push(x);
    }
    return _results;
  })());

  Dcpu.ReservedOp = ((function() {
    var _results;
    _results = [];
    for (x in Dcpu.BinaryOp) {
      _results.push(x);
    }
    return _results;
  })()).concat((function() {
    var _results;
    _results = [];
    for (x in Dcpu.SpecialOp) {
      _results.push(x);
    }
    return _results;
  })()).concat(["jmp", "brk", "ret", "bra", "dat", "org", "equ"]);

  exports.Dcpu = Dcpu;

  AssemblerError = (function() {

    function AssemblerError(text, pos, reason) {
      this.text = text;
      this.pos = pos;
      this.reason = reason;
      this.message = this.format(this.reason);
      this.type = "AssemblerError";
    }

    AssemblerError.prototype.format = function(reason) {
      var i, spacer;
      spacer = this.pos === 0 ? "" : ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.pos; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(" ");
        }
        return _results;
      }).call(this)).join("");
      return "\n" + this.text + "\n" + spacer + "^\n" + reason + "\n";
    };

    return AssemblerError;

  })();

  exports.AssemblerError = AssemblerError;



  Expression = (function() {

    Expression.prototype.Register = function(text, pos, r) {
      var e;
      e = new Expression(text, pos);
      e.register = r;
      e.evaluate = function(symtab) {
        throw new AssemblerError(this.text, this.pos, "Constant expressions may not contain register references");
      };
      e.toString = function() {
        if (this.register) {
          return Dcpu.RegisterNames[this.register];
        }
      };
      e.resolvable = function(symtab) {
        return true;
      };
      return e;
    };

    Expression.prototype.Literal = function(text, pos, n) {
      var e;
      if (n > 0xffff || n < -0x8000) {
        throw new AssemblerError(text, pos, "16-bit value is out of range: " + n);
      }
      e = new Expression(text, pos);
      e.literal = n;
      e.evaluate = function(symtab) {
        return this.literal;
      };
      e.toString = function() {
        return this.literal.toString();
      };
      e.resolvable = function(symtab) {
        return true;
      };
      return e;
    };

    Expression.prototype.Label = function(text, pos, x) {
      var e;
      e = new Expression(text, pos);
      e.label = x;
      e.evaluate = function(symtab) {
        if (Dcpu.Reserved[this.label]) {
          throw new AssemblerError(this.text, this.pos, "You can't use " + this.label.toUpperCase() + " in expressions.");
        }
        if (!(symtab[this.label] != null)) {
          throw new AssemblerError(this.text, this.pos, "Can't resolve reference to " + this.label);
        }
        return symtab[this.label];
      };
      e.toString = function() {
        return this.label;
      };
      e.resolvable = function(symtab) {
        return symtab[this.label] != null;
      };
      return e;
    };

    Expression.prototype.Unary = function(text, pos, op, r) {
      var e;
      e = new Expression(text, pos);
      e.unary = op;
      e.right = r;
      e.evaluate = function(symtab) {
        r = this.right.evaluate(symtab);
        switch (this.unary) {
          case '-':
            return -r;
          default:
            return r;
        }
      };
      e.toString = function() {
        return "(" + this.unary + this.right.toString() + ")";
      };
      e.resolvable = function(symtab) {
        return this.right.resolvable(symtab);
      };
      return e;
    };

    Expression.prototype.Binary = function(text, pos, op, l, r) {
      var e;
      e = new Expression(text, pos);
      e.binary = op;
      e.left = l;
      e.right = r;
      e.evaluate = function(symtab) {
        l = this.left.evaluate(symtab);
        r = this.right.evaluate(symtab);
        switch (this.binary) {
          case '+':
            return l + r;
          case '-':
            return l - r;
          case '*':
            return l * r;
          case '/':
            return l / r;
          case '%':
            return l % r;
          case '<<':
            return l << r;
          case '>>':
            return l >> r;
          case '&':
            return l & r;
          case '^':
            return l ^ r;
          case '|':
            return l | r;
          default:
            throw new AssemblerError(this.text, this.pos, "Internal error (undefined binary operator)");
        }
      };
      e.toString = function() {
        return "(" + this.left.toString() + " " + this.binary + " " + this.right.toString() + ")";
      };
      e.resolvable = function(symtab) {
        return this.left.resolvable(symtab) && this.right.resolvable(symtab);
      };
      return e;
    };

    function Expression(text, pos) {
      this.text = text;
      this.pos = pos;
    }

    Expression.prototype.toString = function() {
      throw "must be implemented in objects";
    };

    Expression.prototype.evaluate = function(symtab) {
      throw "must be implemented in objects";
    };

    Expression.prototype.resolvable = function(symtab) {
      throw "must be implemented in objects";
    };

    return Expression;

  })();

  exports.Expression = Expression;

  AssemblerOutput = (function() {

    function AssemblerOutput(errorCount, lines, symtab) {
      var i, line, size, _i, _ref;
      this.errorCount = errorCount;
      this.lines = lines;
      this.symtab = symtab;
      this.lineMap = [];
      for (i = _i = 0, _ref = this.lines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = this.lines[i];
        size = line.data.length;
        if (size === 0) {
          continue;
        }
        this.lineMap.push({
          org: line.org,
          end: line.org + size,
          lineno: i
        });
      }
      this.lineMap.sort(function(a, b) {
        if (a.org > b.org) {
          return 1;
        } else {
          return -1;
        }
      });
    }

    AssemblerOutput.prototype.pack = function() {
      var blocks, data, end, i, j, k, n, org, orgStart, runStart, _i, _ref;
      if (this.cachedPack != null) {
        return this.cachedPack;
      }
      if (this.errorCount > 0 || this.lines.length === 0) {
        return [];
      }
      i = 0;
      end = this.lines.length;
      blocks = [];
      while (i < end) {
        runStart = i;
        orgStart = org = this.lines[i].org;
        while (i < end && this.lines[i].org === org) {
          org += this.lines[i].data.length;
          i++;
        }
        data = new Array(org - orgStart);
        n = 0;
        for (j = _i = runStart; runStart <= i ? _i < i : _i > i; j = runStart <= i ? ++_i : --_i) {
          k = this.lines[j].data.length;
          [].splice.apply(data, [n, (n + k) - n].concat(_ref = this.lines[j].data)), _ref;
          n += k;
        }
        blocks.push({
          org: orgStart,
          data: data
        });
      }
      blocks.sort(function(a, b) {
        return a.org > b.org;
      });
      this.cachedPack = blocks;
      return blocks;
    };

    AssemblerOutput.prototype.memToLine = function(address) {
      var hi, line, lo, n;
      lo = 0;
      hi = this.lineMap.length;
      while (true) {
        if (lo >= hi) {
          return null;
        }
        n = lo + Math.floor((hi - lo) / 2);
        line = this.lineMap[n];
        if ((line.org <= address && address < line.end)) {
          return line.lineno;
        }
        if (address < line.org) {
          hi = n;
        } else {
          lo = n + 1;
        }
      }
    };

    AssemblerOutput.prototype.memToClosestLine = function(address) {
      var c, candidates, hi, line, lo, n, _i, _len,
        _this = this;
      lo = 0;
      hi = this.lineMap.length;
      while (true) {
        if (lo === hi) {
          candidates = [];
          if (hi < this.lineMap.length) {
            candidates.push({
              addr: this.lineMap[hi].org,
              lineno: this.lineMap[hi].lineno
            });
          }
          if (lo > 0) {
            candidates.push({
              addr: this.lineMap[lo - 1].end - 1,
              lineno: this.lineMap[lo - 1].lineno
            });
          }
          for (_i = 0, _len = candidates.length; _i < _len; _i++) {
            c = candidates[_i];
            c.distance = Math.abs(c.addr - address);
          }
          candidates.sort(function(a, b) {
            return a.distance - b.distance;
          });
          if (candidates.length === 0 || candidates[0].distance > 0x100) {
            return null;
          }
          return candidates[0].lineno;
        }
        n = lo + Math.floor((hi - lo) / 2);
        line = this.lineMap[n];
        if ((line.org <= address && address < line.end)) {
          return line.lineno;
        }
        if (address < line.org) {
          hi = n;
        } else {
          lo = Math.min(n + 1, hi);
        }
      }
    };

    AssemblerOutput.prototype.lineToMem = function(lineno) {
      if (lineno < 0 || lineno >= this.lines.length) {
        return null;
      }
      if (this.lines[lineno].data.length === 0) {
        return null;
      }
      return this.lines[lineno].org;
    };

    AssemblerOutput.prototype.createImage = function(memory) {
      var block, j, _i, _j, _len, _ref, _ref1, _ref2;
      if (memory == null) {
        memory = null;
      }
      if (!(memory != null)) {
        memory = new Array(0x10000);
        for (j = _i = 0; 0 <= 0x10000 ? _i < 0x10000 : _i > 0x10000; j = 0 <= 0x10000 ? ++_i : --_i) {
          memory[j] = 0;
        }
      }
      _ref = this.pack();
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        block = _ref[_j];
        [].splice.apply(memory, [(_ref1 = block.org), (block.org + block.data.length) - _ref1].concat(_ref2 = block.data)), _ref2;
      }
      return memory;
    };

    return AssemblerOutput;

  })();

  exports.AssemblerOutput = AssemblerOutput;

  PrettyPrinter = (function() {

    function PrettyPrinter() {}

    PrettyPrinter.prototype.colors = ["37", "33;1", "33", "31", "35", "34", "36", "32"];

    PrettyPrinter.prototype.inColor = function(s, colorIndex) {
      colorIndex %= 8;
      return "\u001b[" + this.colors[colorIndex] + "m" + s + "\u001b[0m";
    };

    PrettyPrinter.prototype.dump = function(obj, colorIndex) {
      if (colorIndex == null) {
        colorIndex = 0;
      }
      switch (typeof obj) {
        case 'undefined':
          return this.inColor("undefined", colorIndex);
        case 'string':
          return this.inColor(this.dumpString(obj), colorIndex);
        case 'number':
          return this.inColor("0x" + obj.toString(16), colorIndex);
        case 'object':
          if (obj instanceof Array) {
            return this.dumpArray(obj, colorIndex + 1);
          } else {
            return this.dumpObject(obj, colorIndex + 1);
          }
          break;
        default:
          return this.inColor(obj.toString(), colorIndex);
      }
    };

    PrettyPrinter.prototype.dumpArray = function(obj, colorIndex) {
      var first, out, _i, _len;
      first = true;
      out = this.inColor("[", colorIndex);
      for (_i = 0, _len = obj.length; _i < _len; _i++) {
        x = obj[_i];
        if (!first) {
          out += this.inColor(",", colorIndex);
        }
        out += this.inColor(" ", colorIndex) + this.dump(x, colorIndex);
        first = false;
      }
      out += this.inColor(" ]", colorIndex);
      return out;
    };

    PrettyPrinter.prototype.dumpObject = function(obj, colorIndex) {
      var first, k, out, v;
      first = true;
      out = this.inColor("{", colorIndex);
      for (k in obj) {
        v = obj[k];
        if (typeof obj[k] !== 'function') {
          if (!first) {
            out += this.inColor(",", colorIndex);
          }
          out += this.inColor(" " + k + ": ", colorIndex) + this.dump(v, colorIndex);
          first = false;
        }
      }
      return out + this.inColor(" }", colorIndex);
    };

    PrettyPrinter.prototype.dumpString = function(s) {
      var ch, hex, i, out, _i, _ref;
      out = "";
      for (i = _i = 0, _ref = s.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        ch = s.charCodeAt(i);
        if (ch < 32 || ch > 127) {
          hex = ch.toString(16);
          while (hex.length < 4) {
            hex = "0" + hex;
          }
          out += "\\u" + hex;
        } else {
          out += s[i];
        }
      }
      return "\"" + out + "\"";
    };

    return PrettyPrinter;

  })();

  exports.prettyPrinter = new PrettyPrinter;

}).call(this);
var d16bunny = exports; delete exports;
